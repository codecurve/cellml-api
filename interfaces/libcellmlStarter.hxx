/* This file is automatically generated from libcellmlStarter.idl
 * DO NOT EDIT DIRECTLY OR CHANGES WILL BE LOST!
 */
#ifndef _GUARD_libcellmlStarter
#define _GUARD_libcellmlStarter
#include "cda_compiler_support.h"
#include "libcellmlBase.hxx"
#include "DOM_APISPEC.hxx"
#include "MathML_content_APISPEC.hxx"


/* Forward definitions... */
namespace libcellml
{
  class Model;
  

  class Encapsulation;
  

  class CellMLComponent;
  

  class ImportComponent;
  

  class ImportUnits;
  

  class Units;
  

  class Unit;
  

  class CellMLImport;
  

  class CellMLVariable;
  

  class ComponentRef;
  

  class Connection;
  

  class MapVariables;
  

  class VariableRef;
  

  class ExtensionElementList;
  

  class ExtensionAttributeSet;
  

  class MathList;
  

  class ModelSet;
  

  class CellMLElementSet;
  

  class CellMLComponentSet;
  

  class ImportComponentSet;
  

  class CellMLVariableSet;
  

  class UnitsSet;
  

  class CellMLImportSet;
  

  class ImportUnitsSet;
  

  class UnitSet;
  

  class ConnectionSet;
  

  class ComponentRefSet;
  

  class MapVariablesSet;
  

  class VariableRefSet;
  

  typedef dom::Element* ExtensionElement;
  

  typedef std::wstring& CellMLAttributeString;
  

  typedef mathml_dom::MathMLElement* MathMLElement;
  

  /**
     * This interface is the generic base class for all RDF representations.
     */
  class RDFRepresentation
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::RDFRepresentation"; }
    virtual ~RDFRepresentation() {}
    

    virtual std::wstring type() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * The RDF representation for type="http://www.cellml.org/RDFXML/DOM"
     */
  class RDFXMLDOMRepresentation
   : public virtual libcellml::RDFRepresentation
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::RDFXMLDOMRepresentation"; }
    virtual ~RDFXMLDOMRepresentation() {}
    

    virtual std::shared_ptr<dom::Document>  data() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void data(dom::Document* attr) throw(std::exception&) = 0;
  };
  

  /**
     * The RDF representation for type="http://www.cellml.org/RDFXML/string"
     */
  class RDFXMLStringRepresentation
   : public virtual libcellml::RDFRepresentation
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::RDFXMLStringRepresentation"; }
    virtual ~RDFXMLStringRepresentation() {}
    

    virtual std::wstring serialisedData() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void serialisedData(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * This interface can be inherited from by the user for use in annotations.
     *
     * See also the optional AnnoTools service, which provides a higher-level
     * interface on top of this facility.
     */
  class UserData
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::UserData"; }
    virtual ~UserData() {}
  };
  

  /**
     * This interface is implemented by the application to receive notification
     * when an asynchronous import instantiatiation is complete.
     */
  class ImportInstantiationListener
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportInstantiationListener"; }
    virtual ~ImportInstantiationListener() {}
    

    /**
         * This is called after imports have been instantiated.
         * @param wasStale If an xlink:href was changed while the corresponding
         *                 import was loading.
         */
    virtual void loadCompleted(bool wasStale) throw(std::exception&) = 0;
  };
  

  /**
     * Indicates that something went wrong. Implementations are free to add more
     * attributes to this, but to support all implementations, these are not
     * required.
     */
  classCellMLException : public std::exception
  {
  public:
      CellMLException(const std::wstring& _explanation) : explanation(_explanation){}
      ~CellMLException() throw() {}
    std::wstring explanation;
  };
  

  /**
     * Represents a uniform resource indicator, conforming to RFC2396
     * (http://rfc.net/rfc2396.html).
     */
  class URI
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::URI"; }
    virtual ~URI() {}
    

    virtual std::wstring asText() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void asText(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * This is a general interface from which all CellML elements inherit.
     */
  class CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLElement"; }
    virtual ~CellMLElement() {}
    

    virtual std::wstring cellmlVersion() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring cmetaId() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void cmetaId(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::ExtensionElementList>  extensionElements() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Insert an element into the collection of extension elements without
         * disturbing the order of the existing elements.
         * @param marker The element after which to insert the element. If this is
         *               nil, then the insertion will be at the start of the list.
         * @param newEl The new element to insert.
         */
    virtual void insertExtensionElementAfter(dom::Element* marker, dom::Element* newEl) throw(std::exception&) = 0;
    

    /**
         * Equivalent to insertExtensionElementAfter(last extension element, x).
         * @param x The element to append.
         */
    virtual void appendExtensionElement(dom::Element* x) throw(std::exception&) = 0;
    

    /**
         * Equivalent to insertExtensionElementAfter(nil, x)
         * @param x The element to prepend.
         */
    virtual void prependExtensionElement(dom::Element* x) throw(std::exception&) = 0;
    

    /**
         * Remove an extension element. If the element is not found,
         * do nothing.
         * @param x The element to remove.
         */
    virtual void removeExtensionElement(dom::Element* x) throw(std::exception&) = 0;
    

    /**
         * Find an extension element, and if it is found, replace it
         * with another element.
         * @param x The element to find.
         * @param y The element to replace x with.
         */
    virtual void replaceExtensionElement(dom::Element* x, dom::Element* y) throw(std::exception&) = 0;
    

    /**
         * Remove all extension elements from this element.
         */
    virtual void clearExtensionElements() throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLElementSet>  childElements() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Add a CellML element to this element. Checking is performed to ensure
         * that it is a type of element that is allowed in this type of element,
         * and if it is not, an exception is raised. Checking is also performed to
         * ensure that the element belongs in this Model, and that it is not
         * already inserted into the document.
         * @param x The CellMLElement to add.
         * @exception CellMLException if the element cannot be added to this Element.
         */
    virtual void addElement(libcellml::CellMLElement* x) throw(std::exception&) = 0;
    

    /**
         * Removes a CellML element from this element.
         * @param x The CellMLElement to remove.
         */
    virtual void removeElement(libcellml::CellMLElement* x) throw(std::exception&) = 0;
    

    /**
         * Removes a CellML element from this element, and replaces it with another
         * CellML element.
         * @exception CellMLException if the new element is of a type not allowed in
         *                            this Element type, or belongs to the wrong Model.
         * @param x The CellMLElement to remove.
         * @param y The CellMLElement to add.
         */
    virtual void replaceElement(libcellml::CellMLElement* x, libcellml::CellMLElement* y) throw(std::exception&) = 0;
    

    /**
         * Remove a CellML element by name, or do nothing if that element is not
         * found.
         * @param type The type of element("variable", "component", etc...)
         * @param name The name to remove.
         */
    virtual void removeByName(const std::wstring& type, const std::wstring& name) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLElement>  parentElement() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::Model>  modelElement() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Sets user-supplied annotations on this element. These annotations are
         * never read from an XML file or written out, but are for the application
         * to use for any purpose it likes.
         * Implementations in languages in which the ability to do this on any
         * object is built in may choose not to implement this, provided that the
         * implementation does not offer the possibility of remote access to the
         * object.
         * It is recommended that the key be a URL under the control of the person
         * defining the meaning of the key.
         * If the key already exists, then the existing user-data should be removed
         * and the new user-data added.
         * @param key  A string to identify the annotation.
         * @param data The data to set, or nil to clear the UserData for a key.
         */
    virtual void setUserData(const std::wstring& key, libcellml::UserData* data) throw(std::exception&) = 0;
    

    /**
         * Retrieves user-supplied annotations previously set on this element.
         * @param key A string to identify the annotation.
         * @return The user-data associated with the key.
         * @exception CellMLException if no UserData is set for the given key.
         */
    virtual std::shared_ptr<libcellml::UserData>  getUserData(const std::wstring& key) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Retrieves user-supplied annotations previously set on this element,
         * or the default value.
         * @param key A string to identify the annotation.
         * @param defval A default value to return if the key isn't found.
         * @return The user-data associated with the key or the default value.
         */
    virtual std::shared_ptr<libcellml::UserData>  getUserDataWithDefault(const std::wstring& key, libcellml::UserData* defval) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Clones a CellMLElement, and optionally all children.
         * This will not clone the contents of imported models.
         * @param deep If false, only clones the element. It will then have no children.
         *             If true, clones the element, and its children, which are added
         *               into the new element.
         */
    virtual std::shared_ptr<libcellml::CellMLElement>  clone(bool deep) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetches an extension attribute.
         * @param ns The namespace of the extension attribute to fetch.
         * @param localName The local name of the attribute to fetch.
         */
    virtual std::wstring getExtensionAttributeNS(const std::wstring& ns, const std::wstring& localName) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Sets an extension attribute (adding it if it doesn't already exist,
         * otherwise replacing it).
         * @param ns The namespace of the extension attribute to set.
         * @param qualifiedName The qualified name of the attribute to set.
         * @param value The value to set the attribute to.
         */
    virtual void setExtensionAttributeNS(const std::wstring& ns, const std::wstring& qualifiedName, const std::wstring& value) throw(std::exception&) = 0;
    

    /**
         * Removes an extension attribute. No action is taken if the attribute is
         * not already present.
         * @param ns The namespace of the extension attribute to remove.
         * @param localName The local name of the attribute to remove.
         */
    virtual void removeExtensionAttributeNS(const std::wstring& ns, const std::wstring& localName) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::ExtensionAttributeSet>  extensionAttributes() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * This is an optional additional interface which CellMLElements may
     * implement. It provides a link between CellML elements and DOM elements.
     *
     * API users should be aware that not all API implementations will provide
     * this interface.
     */
  class CellMLDOMElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLDOMElement"; }
    virtual ~CellMLDOMElement() {}
    

    virtual std::shared_ptr<dom::Element>  domElement() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Retrieves the CellMLElement corresponding to a dom::Element, if one
         * exists. Otherwise, returns null.
         * @param x The DOM element to look up.
         * @return The corresponding CellML element, or null.
         */
    virtual std::shared_ptr<libcellml::CellMLElement>  findCellMLElementFromDOMElement(dom::Element* x) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * This is a general interface from which all CellML elements which have a
     * name attribute inherit.
     */
  class NamedCellMLElement
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::NamedCellMLElement"; }
    virtual ~NamedCellMLElement() {}
    

    virtual std::wstring name() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void name(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * This interface represents a &lt;model> element in the XML.
     */
  class Model
   : public virtual libcellml::NamedCellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::Model"; }
    virtual ~Model() {}
    

    /**
         * This allows a model with a different cellmlVersion to be returned. This
         * function changes the namespace of the CellML attributes, but it does not
         * change the model structure (even if, for example, this produces a model
         * with import elements in the CellML 1.0 namespace). Applications should
         * use a flattening ModelTransformationService if they wish to change
         * CellML 1.1 import structures into valid CellML 1.0 constructs.
         * @param cellmlVersion The new version of CellML. The string should be 1.0
         *                      or 1.1
         * @exception CellMLException if the version is not supported by the API.
         */
    virtual std::shared_ptr<libcellml::Model>  getAlternateVersion(const std::wstring& cellmlVersion) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    typedef std::vector<std::shared_ptr<libcellml::Encapsulation> >& EncapsulationsT;
    

    virtual std::vector<std::shared_ptr<libcellml::Encapsulation> > encapsulations() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLImportSet>  imports() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::URI>  base_uri() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::UnitsSet>  localUnits() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::UnitsSet>  modelUnits() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::UnitsSet>  allUnits() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponentSet>  localComponents() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponentSet>  modelComponents() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponentSet>  allComponents() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::ConnectionSet>  connections() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * This fully instantiates the import definitions. It will then recursively
         * instantiate all imports in the imported models.
         */
    virtual void fullyInstantiateImports() throw(std::exception&) = 0;
    

    /**
         * This starts an asynchronous full instantiatation of the import
         * definitions. It will then recursively instantiate all imports in the
         * imported models.
         * @param listener A listener which will be notified when imports are instantiated.
         */
    virtual void asyncFullyInstantiateImports(libcellml::ImportInstantiationListener* listener) throw(std::exception&) = 0;
    

    /**
         * Creates a new (local) CellMLComponent.
         */
    virtual std::shared_ptr<libcellml::CellMLComponent>  createComponent() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new ImportComponent.
         */
    virtual std::shared_ptr<libcellml::ImportComponent>  createImportComponent() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new (local) Units.
         */
    virtual std::shared_ptr<libcellml::Units>  createUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new ImportUnits.
         */
    virtual std::shared_ptr<libcellml::ImportUnits>  createImportUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new Unit.
         */
    virtual std::shared_ptr<libcellml::Unit>  createUnit() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new CellMLImport.
         */
    virtual std::shared_ptr<libcellml::CellMLImport>  createCellMLImport() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new CellMLVariable.
         */
    virtual std::shared_ptr<libcellml::CellMLVariable>  createCellMLVariable() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new ComponentRef.
         */
    virtual std::shared_ptr<libcellml::ComponentRef>  createComponentRef() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new Encapsulation.
         */
    virtual std::shared_ptr<libcellml::Encapsulation>  createEncapsulation() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new Connection. This also creates the MapComponents.
         */
    virtual std::shared_ptr<libcellml::Connection>  createConnection() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new MapVariables.
         */
    virtual std::shared_ptr<libcellml::MapVariables>  createMapVariables() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new VariableRef.
         */
    virtual std::shared_ptr<libcellml::VariableRef>  createVariableRef() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new MathMLMathElement.
         * @return The new MathML math element.
         */
    virtual std::shared_ptr<mathml_dom::MathMLMathElement>  createMathElement() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new extension element.
         * @param namespaceURI The new namespace URI.
         * @param qualifiedName The new (optionally) qualified name.
         */
    virtual std::shared_ptr<dom::Element>  createExtensionElement(const std::wstring& namespaceURI, const std::wstring& qualifiedName) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring serialisedText() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * The RDF metadata associated with all elements in this document.
         * @param type The URN describing the type of RDF metadata. Implementations
         *             are free to add new types by creating new type names at URNs
         *             under their jurisdiction. New URNs under http://www.cellml.org
         *             are reserved for future versions of this specification.
         * @return The object containing the RDF representation. The object may
         *         be cast in an application defined manner depending on the type
         *         returned.
         * @exception CellMLException if type isn't supported.
         * All implementations must implement the following types:
         *             http://www.cellml.org/RDFXML/string
         *             http://www.cellml.org/RDFXML/DOM
         */
    virtual std::shared_ptr<libcellml::RDFRepresentation>  getRDFRepresentation(const std::wstring& type) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Clones a Model, including all of its imports.
         * Will cause the model to be fully instantiated.
         * @exception CellMLException if problems occur instantiating imports.
         */
    virtual std::shared_ptr<libcellml::Model>  cloneAcrossImports() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::URI>  xmlBase() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Removes the xml:base from the model entirely.
         */
    virtual void clearXMLBase() throw(std::exception&) = 0;
  };
  

  class MathContainer
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::MathContainer"; }
    virtual ~MathContainer() {}
    

    virtual std::shared_ptr<libcellml::MathList>  math() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Add an element to this collection.
         * @param x The element to add.
         * @exception CellMLException if the element cannot be added to this MathContainer.
         */
    virtual void addMath(mathml_dom::MathMLElement* x) throw(std::exception&) = 0;
    

    /**
         * Remove an element from this collection. If the element is not found,
         * do nothing.
         * @param x The element to remove.
         * @exception CellMLException if the type of element is such that removing the
         *                            element from the DOM is not permissible. This exception
         *                            is not raised merely because x is not in the MathContainer.
         */
    virtual void removeMath(mathml_dom::MathMLElement* x) throw(std::exception&) = 0;
    

    /**
         * Find an element in this collection, and if it is found, replace it
         * with another element.
         * @param x The element to find.
         * @param y The element to replace x with.
         * @exception CellMLException If y is not valid according to the constraints
         *                            on this collection (check optional).
         */
    virtual void replaceMath(mathml_dom::MathMLElement* x, mathml_dom::MathMLElement* y) throw(std::exception&) = 0;
    

    /**
         * Remove all elements in this collection.
         */
    virtual void clearMath() throw(std::exception&) = 0;
  };
  

  /**
     * This interface represents a component element in the CellML document.
     */
  class CellMLComponent
   : public virtual libcellml::NamedCellMLElement , public virtual libcellml::MathContainer
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLComponent"; }
    virtual ~CellMLComponent() {}
    

    virtual std::shared_ptr<libcellml::CellMLVariableSet>  variables() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::UnitsSet>  units() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::ConnectionSet>  connections() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponent>  encapsulationParent() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponentSet>  encapsulationChildren() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponent>  containmentParent() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponentSet>  containmentChildren() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual uint32_t importNumber() throw(std::exception&)  = 0;
  };
  

  class Units
   : public virtual libcellml::NamedCellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::Units"; }
    virtual ~Units() {}
    

    virtual bool isBaseUnits() throw(std::exception&)  = 0;
    virtual void isBaseUnits(bool attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::UnitSet>  unitCollection() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * Interface to a &lt;unit> element.
     */
  class Unit
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::Unit"; }
    virtual ~Unit() {}
    

    virtual int32_t prefix() throw(std::exception&)  = 0;
    virtual void prefix(int32_t attr) throw(std::exception&) = 0;
    

    virtual double multiplier() throw(std::exception&)  = 0;
    virtual void multiplier(double attr) throw(std::exception&) = 0;
    

    virtual double offset() throw(std::exception&)  = 0;
    virtual void offset(double attr) throw(std::exception&) = 0;
    

    virtual double exponent() throw(std::exception&)  = 0;
    virtual void exponent(double attr) throw(std::exception&) = 0;
    

    virtual std::wstring units() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void units(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * This interface represents a CellML import element.
     */
  class CellMLImport
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLImport"; }
    virtual ~CellMLImport() {}
    

    virtual std::shared_ptr<libcellml::URI>  xlinkHref() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::ImportComponentSet>  components() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::ImportUnitsSet>  units() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::ConnectionSet>  importedConnections() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Causes the model referenced by the href attribute to be loaded using the
         * same model loader used to load this model.
         */
    virtual void instantiate() throw(std::exception&) = 0;
    

    /**
         * Causes the model referenced by the href attribute to be asynchronously
         * loaded using the same model loader used to load this model.
         * @param listener The listener to load the model with.
         */
    virtual void asyncInstantiate(libcellml::ImportInstantiationListener* listener) throw(std::exception&) = 0;
    

    /**
         * Causes this import to be instantiated from text.
         * @param xmlText The serialised XML document for the import.
         * @exception CellMLException if xmlText is not valid.
         */
    virtual void instantiateFromText(const std::wstring& xmlText) throw(std::exception&) = 0;
    

    virtual bool wasInstantiated() throw(std::exception&)  = 0;
    

    virtual uint32_t uniqueIdentifier() throw(std::exception&)  = 0;
    

    virtual std::shared_ptr<libcellml::Model>  importedModel() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Causes the model to be uninstantiated, so that it can be re-instantiated
         * in the future.
         */
    virtual void uninstantiate() throw(std::exception&) = 0;
  };
  

  /**
     * This interface represents a component element inside an import element.
     *
     * If the import has not yet been instantiated, then accessing many
     * of the attributes from the CellMLComponent interface, available
     * here by inheritance, will raise a CellMLException.  The
     * attributes name, parentElement, and modelElement are safe to
     * access.
     */
  class ImportComponent
   : public virtual libcellml::CellMLComponent
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportComponent"; }
    virtual ~ImportComponent() {}
    

    virtual std::wstring componentRef() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void componentRef(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * This interface represents a &lt;units> found in &lt;import>
     */
  class ImportUnits
   : public virtual libcellml::Units
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportUnits"; }
    virtual ~ImportUnits() {}
    

    virtual std::wstring unitsRef() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void unitsRef(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * Represents a &lt;variable> element in a CellML document.
     */
  class CellMLVariable
   : public virtual libcellml::NamedCellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLVariable"; }
    virtual ~CellMLVariable() {}
    

    virtual std::wstring initialValue() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void initialValue(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual bool initialValueFromVariable() throw(std::exception&)  = 0;
    

    virtual std::shared_ptr<libcellml::CellMLVariable>  initialValueVariable() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void initialValueVariable(libcellml::CellMLVariable* attr) throw(std::exception&) = 0;
    

    virtual double initialValueValue() throw(std::exception&)  = 0;
    virtual void initialValueValue(double attr) throw(std::exception&) = 0;
    

    virtual bool privateInterface() throw(std::exception&)  = 0;
    virtual void privateInterface(bool attr) throw(std::exception&) = 0;
    

    virtual bool publicInterface() throw(std::exception&)  = 0;
    virtual void publicInterface(bool attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLVariableSet>  connectedVariables() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::CellMLVariable>  sourceVariable() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring componentName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring unitsName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void unitsName(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::Units>  unitsElement() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void unitsElement(libcellml::Units* attr) throw(std::exception&) = 0;
  };
  

  /**
     * Represents a &lt;component_ref> element in a group element or in another
     * &lt;component_ref> element.
     */
  class ComponentRef
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ComponentRef"; }
    virtual ~ComponentRef() {}
    

    virtual std::wstring componentName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void componentName(const std::wstring& attr) throw(std::exception&) = 0;
    

    typedef std::vector<std::shared_ptr<libcellml::ComponentRef> >& ComponentRefsT;
    

    virtual std::vector<std::shared_ptr<libcellml::ComponentRef> > componentRefs() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::ComponentRef>  parentComponentRef() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::Encapsulation>  encapsulationParent() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * Represents a relationship_ref element in a group element.
     */
  class RelationshipRef
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::RelationshipRef"; }
    virtual ~RelationshipRef() {}
    

    virtual std::wstring name() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void name(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::wstring relationship() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring relationshipNamespace() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Sets the namespace and relationship name. This will remove any other
         * relationship attributes in any namespace.
         * @param namespaceURI The URI of the namespace 
         * @param name The name of the relationship.
         */
    virtual void setRelationshipName(const std::wstring& namespaceURI, const std::wstring& name) throw(std::exception&) = 0;
  };
  

  /**
     * Represents a &lt;encapsulation> element.
     */
  class Encapsulation
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::Encapsulation"; }
    virtual ~Encapsulation() {}
    

    virtual std::shared_ptr<libcellml::ComponentRefSet>  componentRefs() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * Represents a &lt;connection> element.
     */
  class Connection
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::Connection"; }
    virtual ~Connection() {}
    

    virtual std::shared_ptr<libcellml::MapVariablesSet>  variableMappings() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring firstComponentName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void firstComponentName(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::wstring secondComponentName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void secondComponentName(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponent>  firstComponent() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void firstComponent(libcellml::CellMLComponent* attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLComponent>  secondComponent() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void secondComponent(libcellml::CellMLComponent* attr) throw(std::exception&) = 0;
  };
  

  /**
     * An interface the map_variables element.
     */
  class MapVariables
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::MapVariables"; }
    virtual ~MapVariables() {}
    

    virtual std::wstring firstVariableName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void firstVariableName(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::wstring secondVariableName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void secondVariableName(const std::wstring& attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLVariable>  firstVariable() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void firstVariable(libcellml::CellMLVariable* attr) throw(std::exception&) = 0;
    

    virtual std::shared_ptr<libcellml::CellMLVariable>  secondVariable() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void secondVariable(libcellml::CellMLVariable* attr) throw(std::exception&) = 0;
  };
  

  class VariableRef;
  

  /**
     * An interface to the &lt;variable_ref> element.
     */
  class VariableRef
   : public virtual libcellml::CellMLElement
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::VariableRef"; }
    virtual ~VariableRef() {}
    

    virtual std::shared_ptr<libcellml::CellMLVariable>  variable() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void variable(libcellml::CellMLVariable* attr) throw(std::exception&) = 0;
    

    virtual std::wstring variableName() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    virtual void variableName(const std::wstring& attr) throw(std::exception&) = 0;
  };
  

  /**
     * An interface allowing CellMLElements to be iterated.
     */
  class CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLElementIterator"; }
    virtual ~CellMLElementIterator() {}
    

    /**
         * Fetches the next CellML element, and advances the iterator.
         * @return The next CellML element, or nil if there are no more CellML
         *         elements.
         */
    virtual std::shared_ptr<libcellml::CellMLElement>  next() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing MathMLElements to be iterated.
     */
  class MathMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::MathMLElementIterator"; }
    virtual ~MathMLElementIterator() {}
    

    /**
         * Fetches the next MathML element, and advances the iterator.
         * @return The next MathML element, or nil if there are no more MathML
         *         elements.
         */
    virtual std::shared_ptr<mathml_dom::MathMLElement>  next() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * A collection of extension elements.
     */
  class ExtensionElementList
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ExtensionElementList"; }
    virtual ~ExtensionElementList() {}
    

    virtual uint32_t length() throw(std::exception&)  = 0;
    

    /**
         * Tests for the existance of an element in the set.
         * @param x The element to test for.
         * @return true if the element is present, or false otherwise.
         */
    virtual bool contains(dom::Element* x) throw(std::exception&) = 0;
    

    /**
         * Finds the index of the given extension element.
         * @param x The extension element to find.
         * @return The index(first is 0) of the extension element, or -1 if the
         *         element is not found.
         */
    virtual int32_t getIndexOf(dom::Element* x) throw(std::exception&) = 0;
    

    /**
         * Fetches the extension element at a certain index(starting from 0).
         * @param index The index at which to fetch the extension element.
         */
    virtual std::shared_ptr<dom::Element>  getAt(uint32_t index) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * A collection of math.
     */
  class MathList
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::MathList"; }
    virtual ~MathList() {}
    

    virtual uint32_t length() throw(std::exception&)  = 0;
    

    /**
         * Tests for the existance of an element in the set.
         * @param x The element to test for.
         * @return true if the element is present, or false otherwise.
         */
    virtual bool contains(mathml_dom::MathMLElement* x) throw(std::exception&) = 0;
    

    /**
         * Returns a CellMLElementIterator that can be used to iterate through the
         * elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::MathMLElementIterator>  iterate() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for iterating through all extension attributes.
     */
  class ExtensionAttributeIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ExtensionAttributeIterator"; }
    virtual ~ExtensionAttributeIterator() {}
    

    /**
         * Fetches the next extension attribute node.
         */
    virtual std::shared_ptr<dom::Attr>  nextAttribute() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * A set of extension attributes
     */
  class ExtensionAttributeSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ExtensionAttributeSet"; }
    virtual ~ExtensionAttributeSet() {}
    

    /**
         * Returns a CellMLElementIterator that can be used to iterate through the
         * attributes. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::ExtensionAttributeIterator>  iterate() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An immutable collection of CellML elements.
     */
  class CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLElementSet"; }
    virtual ~CellMLElementSet() {}
    

    virtual uint32_t length() throw(std::exception&)  = 0;
    

    /**
         * Tests for the existance of an element in the set.
         * @param x The element to test for.
         * @return true if the element is present, or false otherwise.
         */
    virtual bool contains(libcellml::CellMLElement* x) throw(std::exception&) = 0;
    

    /**
         * Returns a CellMLElementIterator that can be used to iterate through the
         * elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::CellMLElementIterator>  iterate() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a collection of NamedCellMLElements. It is
     * an error if any element in this collection does not inherit from
     * NamedCellMLElement.
     */
  class NamedCellMLElementSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::NamedCellMLElementSet"; }
    virtual ~NamedCellMLElementSet() {}
    

    /**
         * Fetch a NamedCellMLElement by name.
         * @param name The name of the element
         * @return The element, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::NamedCellMLElement>  get(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing Model elements to be iterated.
     */
  class ModelIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ModelIterator"; }
    virtual ~ModelIterator() {}
    

    /**
         * Fetches the next Model, and advances the iterator.
         * @return The next Model, or nil if there are no more Model elements.
         */
    virtual std::shared_ptr<libcellml::Model>  nextModel() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a collection of models.
     */
  class ModelSet
   : public virtual libcellml::NamedCellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ModelSet"; }
    virtual ~ModelSet() {}
    

    /**
         * Returns a ModelIterator that can be used to iterate through the
         * Model elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::ModelIterator>  iterateModels() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetch a Model by name.
         * @param name The name of the Model
         * @return The Model, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::Model>  getModel(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing CellMLComponents to be iterated.
     */
  class CellMLComponentIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLComponentIterator"; }
    virtual ~CellMLComponentIterator() {}
    

    /**
         * Fetches the next CellMLComponent, and advances the iterator.
         * @return The next CellMLComponent, or nil if there are no more
         *         CellMLComponents.
         */
    virtual std::shared_ptr<libcellml::CellMLComponent>  nextComponent() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of CellMLComponents.
     */
  class CellMLComponentSet
   : public virtual libcellml::NamedCellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLComponentSet"; }
    virtual ~CellMLComponentSet() {}
    

    /**
         * Returns a CellMLComponentIterator that can be used to iterate through the
         * CellMLComponent elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::CellMLComponentIterator>  iterateComponents() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetch a component by name.
         * @param name The name of the CellMLComponent.
         * @return The CellMLComponent, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::CellMLComponent>  getComponent(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing ImportComponents to be iterated.
     */
  class ImportComponentIterator
   : public virtual libcellml::CellMLComponentIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportComponentIterator"; }
    virtual ~ImportComponentIterator() {}
    

    /**
         * Fetches the next ImportComponent, and advances the iterator.
         * @return The next ImportComponent, or nil if there are no more
         *         ImportComponents.
         */
    virtual std::shared_ptr<libcellml::ImportComponent>  nextImportComponent() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of ImportComponents.
     */
  class ImportComponentSet
   : public virtual libcellml::CellMLComponentSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportComponentSet"; }
    virtual ~ImportComponentSet() {}
    

    /**
         * Returns an ImportComponentIterator that can be used to iterate through
         * the ImportComponents. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::ImportComponentIterator>  iterateImportComponents() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetch an ImportComponent by name.
         * @param name The name of the component, as given by the importing model.
         * @return The element, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::ImportComponent>  getImportComponent(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing CellMLVariables to be iterated.
     */
  class CellMLVariableIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLVariableIterator"; }
    virtual ~CellMLVariableIterator() {}
    

    /**
         * Fetches the next CellMLVariable, and advances the iterator.
         * @return The next CellMLVariable, or nil if there are no more
         *         CellMLVariable elements.
         */
    virtual std::shared_ptr<libcellml::CellMLVariable>  nextVariable() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of CellMLVariable elements.
     */
  class CellMLVariableSet
   : public virtual libcellml::NamedCellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLVariableSet"; }
    virtual ~CellMLVariableSet() {}
    

    /**
         * Returns a CellMLVariableIterator that can be used to iterate through the
         * CellMLVariable elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::CellMLVariableIterator>  iterateVariables() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetch a variable by name.
         * @param name The name of the variable.
         * @return The CellMLVariable, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::CellMLVariable>  getVariable(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing Units to be iterated.
     */
  class UnitsIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::UnitsIterator"; }
    virtual ~UnitsIterator() {}
    

    /**
         * Fetches the next Units element, and advances the iterator.
         * @return The next Units element, or nil if there are no more Units
         *         elements.
         */
    virtual std::shared_ptr<libcellml::Units>  nextUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of Units.
     */
  class UnitsSet
   : public virtual libcellml::NamedCellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::UnitsSet"; }
    virtual ~UnitsSet() {}
    

    /**
         * Returns a UnitsIterator that can be used to iterate through the
         * Units elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::UnitsIterator>  iterateUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetch a Units element by name.
         * @param name The name of the units.
         * @return The Units element, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::Units>  getUnits(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing ImportUnits to be iterated.
     */
  class ImportUnitsIterator
   : public virtual libcellml::UnitsIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportUnitsIterator"; }
    virtual ~ImportUnitsIterator() {}
    

    /**
         * Fetches the next ImportUnits element, and advances the iterator.
         * @return The next ImportUnits element, or nil if there are no more
         * ImportUnits elements.
         */
    virtual std::shared_ptr<libcellml::ImportUnits>  nextImportUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of ImportUnits.
     */
  class ImportUnitsSet
   : public virtual libcellml::UnitsSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ImportUnitsSet"; }
    virtual ~ImportUnitsSet() {}
    

    /**
         * Returns an ImportUnitsIterator that can be used to iterate through the
         * ImportUnits elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::ImportUnitsIterator>  iterateImportUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetch a ImportUnits by name.
         * @param name The name of the units definition, as given by the
         *             importing model.
         * @return The ImportUnits, or nil if not found.
         */
    virtual std::shared_ptr<libcellml::ImportUnits>  getImportUnits(const std::wstring& name) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing Imports to be iterated.
     */
  class CellMLImportIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLImportIterator"; }
    virtual ~CellMLImportIterator() {}
    

    /**
         * Fetches the next import, and advances the iterator.
         * @return The next import, or nil if there are no more imports.
         */
    virtual std::shared_ptr<libcellml::CellMLImport>  nextImport() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of Imports.
     */
  class CellMLImportSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLImportSet"; }
    virtual ~CellMLImportSet() {}
    

    /**
         * Returns a CellMLImportIterator that can be used to iterate through the
         * imports. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::CellMLImportIterator>  iterateImports() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing Unit elements to be iterated.
     */
  class UnitIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::UnitIterator"; }
    virtual ~UnitIterator() {}
    

    /**
         * Fetches the next Unit element, and advances the iterator.
         * @return The next Unit element, or nil if there are no more Unit
         *         elements.
         */
    virtual std::shared_ptr<libcellml::Unit>  nextUnit() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of Unit elements.
     */
  class UnitSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::UnitSet"; }
    virtual ~UnitSet() {}
    

    /**
         * Returns a UnitIterator that can be used to iterate through the
         * unit elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::UnitIterator>  iterateUnits() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing connection elements to be iterated.
     */
  class ConnectionIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ConnectionIterator"; }
    virtual ~ConnectionIterator() {}
    

    /**
         * Fetches the next Connection, and advances the iterator.
         * @return The next Connection, or nil if there are no more Connection
         *         elements.
         */
    virtual std::shared_ptr<libcellml::Connection>  nextConnection() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of connection elements.
     */
  class ConnectionSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ConnectionSet"; }
    virtual ~ConnectionSet() {}
    

    /**
         * Returns a ConnectionIterator that can be used to iterate through the
         * connection elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::ConnectionIterator>  iterateConnections() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing ComponentRef elements to be iterated.
     */
  class ComponentRefIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ComponentRefIterator"; }
    virtual ~ComponentRefIterator() {}
    

    /**
         * Fetches the next ComponentRef, and advances the iterator.
         * @return The next ComponentRef, or nil if there are no more
         *         ComponentRef elements.
         */
    virtual std::shared_ptr<libcellml::ComponentRef>  nextComponentRef() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of ComponentRef elements.
     */
  class ComponentRefSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ComponentRefSet"; }
    virtual ~ComponentRefSet() {}
    

    /**
         * Returns a ComponentRefIterator that can be used to iterate through the
         * ComponentRef elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::ComponentRefIterator>  iterateComponentRefs() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing MapVariables elements to be iterated.
     */
  class MapVariablesIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::MapVariablesIterator"; }
    virtual ~MapVariablesIterator() {}
    

    /**
         * Fetches the next MapVariables element, and advances the iterator.
         * @return The next MapVariables element, or nil if there are no more
         *         MapVariables elements.
         * @deprecated Use nextMapVariables(). This method may be removed from a
         *             future release of the CellML API.
         */
    virtual std::shared_ptr<libcellml::MapVariables>  nextMapVariable() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Fetches the next MapVariables element, and advances the iterator.
         * @return The next MapVariables element, or nil if there are no more
         *         MapVariables elements.
         */
    virtual std::shared_ptr<libcellml::MapVariables>  nextMapVariables() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of MapVariables elements.
     */
  class MapVariablesSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::MapVariablesSet"; }
    virtual ~MapVariablesSet() {}
    

    /**
         * Returns a MapVariablesIterator that can be used to iterate through the
         * MapVariables elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::MapVariablesIterator>  iterateMapVariables() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing VariableRef elements to be iterated.
     */
  class VariableRefIterator
   : public virtual libcellml::CellMLElementIterator
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::VariableRefIterator"; }
    virtual ~VariableRefIterator() {}
    

    /**
         * Fetches the next VariableRef, and advances the iterator.
         * @return The next VariableRef, or nil if there are no more VariableRef
         *         elements.
         */
    virtual std::shared_ptr<libcellml::VariableRef>  nextVariableRef() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface for accessing a set of VariableRef elements.
     */
  class VariableRefSet
   : public virtual libcellml::CellMLElementSet
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::VariableRefSet"; }
    virtual ~VariableRefSet() {}
    

    /**
         * Returns a VariableRefIterator that can be used to iterate through the
         * VariableRef elements. The iteration order is undefined.
         */
    virtual std::shared_ptr<libcellml::VariableRefIterator>  iterateVariableRefs() throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * An interface allowing notifications that model loading has completed to
     * be delivered. This is implemented by the application and not the API.
     */
  class ModelLoadedListener
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ModelLoadedListener"; }
    virtual ~ModelLoadedListener() {}
    

    /**
         * Called when the model has been loaded.
         * @param m The model which has just been loaded.
         */
    virtual void loadCompleted(libcellml::Model* m) throw(std::exception&) = 0;
  };
  

  /**
     * An interface allowing notifications that document loading has completed
     * to be delivered.
     */
  class DocumentLoadedListener
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::DocumentLoadedListener"; }
    virtual ~DocumentLoadedListener() {}
    

    /**
         * Called when the document has been loaded.
         * @param doc The document which has just been loaded.
         */
    virtual void loadCompleted(dom::Document* doc) throw(std::exception&) = 0;
  };
  

  /**
     * An interface for loading a CellML model (from URL or string).
     */
  class ModelLoader
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::ModelLoader"; }
    virtual ~ModelLoader() {}
    

    /**
         * Loads a model from the given URL, using the local URL loader.
         * Note that this operation may be unavailable (or restricted to certain
         * URLs) due to security restrictions on some remotely hosted model
         * loaders.
         * @param URL The URL from which to load the model.
         * @return The loaded CellML model.
         * @exception CellMLException if the model cannot be loaded.
         */
    virtual std::shared_ptr<libcellml::Model>  loadFromURL(const std::wstring& URL) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Loads a model from the given URL asynchronously, using the local URL
         * loader. Note that this operation may be unavailable (or restricted to
         * certain URLs) due to security restrictions on some remotely hosted model
         * loaders. Applications should be aware that the loadCompleted operation on
         * listener may be called prior to the return on this operation.
         * @param URL The URL from which to load the model.
         * @param listener A ModelLoadedListener to inform when loading completes.
         * @exception CellMLException if the model cannot be loaded.
         */
    virtual void asyncLoadFromURL(const std::wstring& URL, libcellml::ModelLoadedListener* listener) throw(std::exception&) = 0;
    

    /**
         * Loads a model from a serialised XML document.
         * @param xmlText A complete XML document, serialised into text.
         * @return The loaded CellML model.
         * @exception CellMLException if the XML cannot be parsed into a model.
         */
    virtual std::shared_ptr<libcellml::Model>  createFromText(const std::wstring& xmlText) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::wstring lastErrorMessage() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * A DOM specific interface for loading a Document.
     */
  class DOMURLLoader
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::DOMURLLoader"; }
    virtual ~DOMURLLoader() {}
    

    /**
         * Loads an XML formatted document from a given URL into a DOM. This may
         * be restricted to certain URLs due to security restrictions on some
         * remotely hosted URL loaders.
         * @param URL The URL from which to load the document.
         * @return The loaded document.
         * @exception CellMLException if the model cannot be loaded.
         */
    virtual std::shared_ptr<dom::Document>  loadDocument(const std::wstring& URL) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Loads an XML formatted document from the given serialised text into a
         * DOM representation.
         * @param xmlText The serialised XML used to create the document.
         * @return The loaded document.
         * @exception CellMLException if the model cannot be loaded.
         */
    virtual std::shared_ptr<dom::Document>  loadDocumentFromText(const std::wstring& xmlText) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Asynchronously loads an XML formatted document from a given URL into a
         * DOM. This may be restricted to certain URLs due to security restrictions
         * on some remotely hosted URL loaders.
         * @param URL The URL from which to load the document.
         * @param listener The listener to notify when the load completes.
         * @exception CellMLException if the model cannot be loaded.
         */
    virtual void asyncLoadDocument(const std::wstring& URL, libcellml::DocumentLoadedListener* listener) throw(std::exception&) = 0;
    

    virtual std::wstring lastErrorMessage() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
  };
  

  /**
     * A DOM specific interface for loading a CellML model with more control.
     */
  class DOMModelLoader
   : public virtual libcellml::ModelLoader
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::DOMModelLoader"; }
    virtual ~DOMModelLoader() {}
    

    /**
         * Loads the DOM for the model from the specified URL using the supplied
         * DOMURLLoader. If further URLs need to be loaded (for example, to satisfy
         * imports), the supplied loader will be used.
         * @param url The URL from which to load.
         * @param loader The URL loader to load the model and any imports needed.
         * @return The loaded model.
         * @exception CellMLException if there is an error loading the model or the
         *                            DOM document.
         */
    virtual std::shared_ptr<libcellml::Model>  createFromDOM(const std::wstring& url, libcellml::DOMURLLoader* loader) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a model around an existing DOM document.
         * @param doc The DOM document.
         * @return The model.
         * @exception CellMLException if there is an error creating the model from
         *                            the DOM document.
         */
    virtual std::shared_ptr<libcellml::Model>  createFromDOMDocument(dom::Document* doc) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Loads the DOM for the model from the specified URL using the supplied
         * DOMURLLoader. If further URLs need to be loaded (for example, to satisfy
         * imports), the supplied loader will be used.
         * @param url The URL from which to load.
         * @param loader The URL loader to load the model and any imports needed.
         * @param listener A listener to notify when the model is fully loaded.
         * @exception CellMLException if there is an error loading the model or the
         *                            DOM document.
         */
    virtual void asyncCreateFromDOM(const std::wstring& url, libcellml::DOMURLLoader* loader, libcellml::ModelLoadedListener* listener) throw(std::exception&) = 0;
  };
  

  /**
     * A DOM specific interface that provides everything an application needs to
     * bootstrap the CellML API.
     */
  class CellMLBootstrap
  {
  public:
    static const char* INTERFACE_NAME() { return "libcellml::CellMLBootstrap"; }
    virtual ~CellMLBootstrap() {}
    

    virtual std::shared_ptr<libcellml::DOMModelLoader>  modelLoader() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<dom::DOMImplementation>  domImplementation() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    virtual std::shared_ptr<libcellml::DOMURLLoader>  localURLLoader() throw(std::exception&)  WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Creates a new, empty, model.
         * @param version The version of the new model. This currently must be
         *                1.0 or 1.1.
         * @exception CellMLException If an invalid version is given.
         */
    virtual std::shared_ptr<libcellml::Model>  createModel(const std::wstring& version) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Serialises a DOM node into a string. The node to serialise must have
         * originated from the locally hosted DOM implementation.
         * @param node The DOM node to serialise.
         * @return The node, as a serialised string.
         */
    virtual std::wstring serialiseNode(dom::Node* node) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
    

    /**
         * Tries to make a relative URL absolute, using a URL specifying what the
         * URL is relative to.
         * @param relTo The absolute URL to evaluate relative to.
         * @param relURL A possibly relative URL to make absolute.
         * @return An absolute URL, if it is possible to produce one, otherwise a relative one.
         */
    virtual std::wstring makeURLAbsolute(const std::wstring& relTo, const std::wstring& relURL) throw(std::exception&) WARN_IF_RETURN_UNUSED = 0;
  };
};
#endif // guard
